//
// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*;      // Must always import this.

/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
// action code {:
// your code goes HERE
//:};

/* User code components 2: parser code components. 
 * Modifications to the default generated parser
 */
parser code {:

    String lastError;
    
    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message  error message to print
     * @param info     symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
    {
    String st =  "Error";
   
        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

        /* s.left is supposed to hold the line number of the error.
         * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
         */
   
            if (s.left >= 0)                // Check line number.
        {
                st += " in line " + (s.left + 1);
                if (s.right >= 0)           // Check column number.
                    st += ", column " + (s.right + 1);
        }
            else
               st += " at end of input " ;
           }
        st += ": " + message;
        System.err.println (st);
        lastError = st;
    }
   
    /** Override the report_fatal_error method to use the report_error method. */
    /** @throws SyntaxErrorException                        */
    public void report_fatal_error (String message, Object info) throws SyntaxErrorException
    {
        report_error (message, info);
        throw new SyntaxErrorException (lastError); 
    }
   
:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here.  Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words.  These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language  Winter  2013/2014 

// Terminals returned by the scanner with no value attached.  
terminal    BOOLEAN,        INTEGER,        DO      ;
terminal    ELSE,   END,    EXIT,   FI,     FORWARD, FUNC ;
terminal    IF,     GET,    PROCEDURE,      PUT     ;
terminal    WHILE,  REPEAT, UNTIL,  VAR,    NEWLINE ;
terminal    RESULT, RETURN, THEN,   WHEN            ;

// Special-character terminals, no value attached
terminal    AND,    OR,     NOT,    TRUE,   FALSE       ;
terminal    L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY ;
terminal    EQUAL,  GREATER,LESS,   COMMA,  DOT, COLON  ;
terminal    PLUS,   MINUS,  TIMES,  DIVIDE, QUESTION    ;

// Terminals returned by the scanner with a value.
terminal String  IDENT      ;
terminal Integer INTCONST   ;
terminal String  TEXTCONST  ;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal program, scope;
nonterminal declaration_list, statement_list, variable_declaration_list,
            parameter_list, argument_list, not_list, input_list, output_list;
nonterminal optional_declaration_list, optional_statement_list, optional_parameter_list, optional_argument_list, optional_not_list;
nonterminal declaration, functionHead, procedureHead,
            parameter, variable_declaration, bound, generalBound, type;
nonterminal statement, variable, output, input, text;
nonterminal variablename, functionname, procedurename;
nonterminal expression, or_expr, and_expr, not_expr, pred_expr, add_expr, mul_expr, unr_expr, term_expr;
nonterminal literal, integer_literal, boolean_literal;

// Non-terminals that have a value.
// nonterminal type  nameList ;

// CSC488S PLEASE NOTE: your grammar CAN NOT use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE;        // Higher precedence.

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it.  This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token.  It ALWAYS
 * reads one more token before it will act on the production.
 */

program
    ::= scope
    ;

scope
    ::= L_CURLEY optional_declaration_list optional_statement_list R_CURLEY
    ;

declaration
    ::= VAR variable_declaration_list COLON type
    |   functionHead scope
    |   procedureHead scope
    |   FORWARD functionHead
    |   FORWARD procedureHead
    ;

functionHead
    ::= FUNC functionname L_PAREN optional_parameter_list R_PAREN COLON type
    ;

procedureHead
    ::= PROCEDURE procedurename L_PAREN optional_parameter_list R_PAREN
    ;

parameter
    ::= variablename COLON type
    ;

variable_declaration
    ::= variablename
    |   variablename L_SQUARE bound R_SQUARE
    |   variablename L_SQUARE bound COMMA bound R_SQUARE
    ;

bound
    ::= INTCONST
    |   generalBound DOT DOT generalBound
    ;

generalBound
    ::= INTCONST
    |   MINUS INTCONST
    ;

type
    ::= INTEGER
    |   BOOLEAN
    ;

statement
    ::= variable COLON EQUAL expression
    |   IF expression THEN statement_list FI
    |   IF expression THEN statement_list ELSE statement_list FI
    |   WHILE expression DO statement_list END
    |   REPEAT statement_list UNTIL expression
    |   EXIT
    |   EXIT WHEN expression
    |   RESULT expression
    |   RETURN
    |   PUT output_list
    |   GET input_list
    |   procedurename L_PAREN optional_argument_list R_PAREN
    |   scope
    ;

variable
    ::= variablename
    |   variablename L_SQUARE expression R_SQUARE
    |   variablename L_SQUARE expression COMMA expression R_SQUARE
    ;

output
    ::= expression
    |   NEWLINE
    |   text
    ;

input
    ::= variable
    ;

text
    ::= TEXTCONST
    ;

expression
    ::= or_expr
    ;


or_expr
    ::= or_expr OR and_expr
    |   and_expr
    ;

and_expr
    ::= and_expr AND not_expr
    |   not_expr
    ;

not_expr
    ::= optional_not_list pred_expr
    ;

pred_expr
    ::= add_expr EQUAL add_expr
    |   add_expr NOT EQUAL add_expr
    |   add_expr LESS add_expr
    |   add_expr LESS EQUAL add_expr
    |   add_expr GREATER add_expr
    |   add_expr GREATER EQUAL add_expr
    |   add_expr
    ;

add_expr
    ::= add_expr PLUS  mul_expr
    |   add_expr MINUS mul_expr
    |   mul_expr
    ;

mul_expr
    ::= mul_expr TIMES unr_expr
    |   mul_expr DIVIDE unr_expr
    |   unr_expr
    ;

unr_expr
    ::= MINUS term_expr 
    |   term_expr
    ;

term_expr
    ::= literal
    |   variable
    |   functionname L_PAREN optional_argument_list R_PAREN
    |   L_PAREN expression R_PAREN
    |   L_PAREN expression QUESTION expression COLON expression R_PAREN
    ;

declaration_list
    ::= declaration_list declaration
    |   declaration
    ;

statement_list
    ::= statement_list statement
    |   statement
    ;

variable_declaration_list
    ::= variable_declaration_list COMMA variable_declaration
    |   variable_declaration
    ;

parameter_list
    ::= parameter_list COMMA parameter
    |   parameter
    ;

argument_list
    ::= argument_list COMMA expression
    |   expression
    ;

not_list
    ::= not_list NOT
    |   NOT
    ;

input_list
    ::= input_list COMMA input
    |   input
    ;

output_list
    ::= output_list COMMA output
    |   output
    ;

optional_declaration_list ::= declaration_list | /* lambda */ ;
optional_statement_list   ::= statement_list   | /* lambda */ ;
optional_parameter_list   ::= parameter_list   | /* lambda */ ;
optional_argument_list    ::= argument_list    | /* lambda */ ;
optional_not_list         ::= not_list         | /* lambda */ ;

literal
    ::= integer_literal
    |   boolean_literal
    ;

integer_literal
    ::= INTCONST
    ;

boolean_literal
    ::= TRUE
    |   FALSE
    ;

variablename  ::= IDENT;
functionname  ::= IDENT;
procedurename ::= IDENT;
